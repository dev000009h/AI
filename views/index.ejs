<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>VMS - Video Management System</title>
    <script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api@latest/dist/face-api.min.js"></script>
</head>
<body>

<div class="vms-container">
    <div class="vms-header">
        <h1>VMS</h1>
        <div class="camera-controls">
            <select id="cameraSelect" class="camera-selector">
                <option value="">Loading cameras...</option>
            </select>
            <button id="flipCamera" class="flip-btn" title="Flip Camera">üì∑</button>
            <button id="registerUserBtn" class="register-btn" title="Register New User">üë§ Register</button>
            <button id="manageUsersBtn" class="manage-btn" title="Manage Users">‚öôÔ∏è Manage</button>
        </div>
    </div>
    
    <div class="camera-feed-container">
        <div class="video-wrapper">
            <video id="video" autoplay muted playsinline></video>
            <canvas id="overlay"></canvas>
        </div>
        
        <div id="recognitionInfo" class="recognition-overlay">
            <div id="userInfo" class="user-info"></div>
        </div>
    </div>
    
    <div id="statusBar" class="status-bar">
        <span id="statusText">Initializing VMS...</span>
        <span id="faceCount" class="face-counter">0 faces detected</span>
    </div>
</div>

<!-- Registration Modal -->
<div id="registrationModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Register New User</h3>
            <button id="closeModal" class="close-btn">&times;</button>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="newUserName">Full Name:</label>
                <input type="text" id="newUserName" placeholder="Enter full name" required>
            </div>
            <div class="registration-preview">
                <video id="registrationVideo" width="300" height="225" autoplay muted playsinline></video>
                <canvas id="registrationOverlay" width="300" height="225"></canvas>
            </div>
            <div id="registrationProgress" class="progress-container" style="display: none;">
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill"></div>
                </div>
                <p id="progressText">Capturing facial data... <span id="timeLeft">5</span>s</p>
            </div>
            <div class="modal-actions">
                <button id="startRegistration" class="btn btn-primary">Start Registration</button>
                <button id="cancelRegistration" class="btn btn-secondary">Cancel</button>
            </div>
        </div>
    </div>
</div>

<!-- User Management Modal -->
<div id="userManagementModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3>User Management</h3>
            <button id="closeUserModal" class="close-btn">&times;</button>
        </div>
        <div class="modal-body">
            <div id="usersList" class="users-list">
                <p>Loading users...</p>
            </div>
        </div>
    </div>
</div>

<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #000; color: #fff; overflow: hidden; height: 100vh; }
.vms-container { height: 100vh; display: flex; flex-direction: column; }

.vms-header { display: flex; justify-content: space-between; align-items: center; padding: 15px 25px; background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(10px); border-bottom: 1px solid rgba(255, 255, 255, 0.1); z-index: 100; }
.vms-header h1 { font-size: 2rem; font-weight: 300; letter-spacing: 3px; color: #00ff88; }
.camera-controls { display: flex; gap: 10px; align-items: center; }
.camera-selector { background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); color: #fff; padding: 8px 12px; border-radius: 6px; font-size: 0.9rem; min-width: 200px; }
.camera-selector option { background: #333; color: #fff; }
.flip-btn { background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); color: #fff; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 1.2rem; transition: all 0.3s ease; }
.flip-btn:hover { background: rgba(255, 255, 255, 0.2); }
.register-btn { background: rgba(0, 255, 136, 0.2); border: 1px solid rgba(0, 255, 136, 0.4); color: #00ff88; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.9rem; font-weight: 500; transition: all 0.3s ease; display: flex; align-items: center; gap: 5px; }
.register-btn:hover { background: rgba(0, 255, 136, 0.3); transform: translateY(-1px); }
.manage-btn { background: rgba(255, 165, 0, 0.2); border: 1px solid rgba(255, 165, 0, 0.4); color: #ffa500; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.9rem; font-weight: 500; transition: all 0.3s ease; display: flex; align-items: center; gap: 5px; }
.manage-btn:hover { background: rgba(255, 165, 0, 0.3); transform: translateY(-1px); }

.camera-feed-container { flex: 1; position: relative; display: flex; justify-content: center; align-items: center; background: #111; }
.video-wrapper { position: relative; max-width: 100%; max-height: 100%; }
#video { width: 100%; height: auto; max-height: calc(100vh - 120px); border-radius: 8px; box-shadow: 0 0 30px rgba(0, 255, 136, 0.3); }
#overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }

.recognition-overlay { position: absolute; top: 20px; left: 20px; right: 20px; z-index: 50; }
.user-info { background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(10px); padding: 15px 20px; border-radius: 10px; border-left: 4px solid #00ff88; display: none; }
.user-info.recognized { border-left-color: #00ff88; display: block; }
.user-info.unknown { border-left-color: #ff4444; display: block; }
.user-info h3 { margin: 0 0 5px 0; font-size: 1.2rem; }
.user-info p { margin: 0; opacity: 0.8; font-size: 0.9rem; }

.status-bar { display: flex; justify-content: space-between; align-items: center; padding: 10px 25px; background: rgba(0, 0, 0, 0.9); border-top: 1px solid rgba(255, 255, 255, 0.1); font-size: 0.9rem; }
.face-counter { color: #00ff88; font-weight: 500; }

.modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); z-index: 1000; backdrop-filter: blur(5px); }
.modal-content { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #222; border-radius: 15px; padding: 0; max-width: 500px; width: 90%; max-height: 90vh; overflow: hidden; box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5); }
.modal-header { display: flex; justify-content: space-between; align-items: center; padding: 20px 25px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
.modal-header h3 { margin: 0; color: #00ff88; }
.close-btn { background: none; border: none; color: #fff; font-size: 1.5rem; cursor: pointer; padding: 0; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; border-radius: 50%; transition: background 0.3s ease; }
.close-btn:hover { background: rgba(255, 255, 255, 0.1); }
.modal-body { padding: 25px; }
.form-group { margin-bottom: 20px; }
.form-group label { display: block; margin-bottom: 8px; color: #ccc; font-weight: 500; }
.form-group input { width: 100%; padding: 12px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; color: #fff; font-size: 1rem; }
.form-group input:focus { outline: none; border-color: #00ff88; box-shadow: 0 0 0 2px rgba(0, 255, 136, 0.2); }

.registration-preview { position: relative; text-align: center; margin: 20px 0; }
#registrationVideo { border-radius: 8px; background: #000; }
#registrationOverlay { position: absolute; top: 0; left: 50%; transform: translateX(-50%); pointer-events: none; }

.progress-container { margin: 20px 0; }
.progress-bar { width: 100%; height: 8px; background: rgba(255, 255, 255, 0.1); border-radius: 4px; overflow: hidden; }
.progress-fill { height: 100%; background: linear-gradient(90deg, #00ff88, #00cc6a); width: 0%; transition: width 0.1s ease; }
#progressText { text-align: center; margin-top: 10px; color: #ccc; }

.modal-actions { display: flex; gap: 10px; justify-content: flex-end; margin-top: 25px; }
.btn { padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; font-weight: 500; transition: all 0.3s ease; }
.btn-primary { background: #00ff88; color: #000; }
.btn-primary:hover { background: #00cc6a; transform: translateY(-1px); }
.btn-secondary { background: rgba(255, 255, 255, 0.1); color: #fff; border: 1px solid rgba(255, 255, 255, 0.2); }
.btn-secondary:hover { background: rgba(255, 255, 255, 0.2); }

.users-list { max-height: 400px; overflow-y: auto; }
.user-item { display: flex; justify-content: space-between; align-items: center; padding: 15px; margin-bottom: 10px; background: rgba(255, 255, 255, 0.05); border-radius: 8px; border-left: 3px solid #00ff88; }
.user-details h4 { margin: 0 0 5px 0; color: #00ff88; font-size: 1.1rem; }
.user-details p { margin: 0; color: #ccc; font-size: 0.9rem; }
.user-actions { display: flex; gap: 10px; }
.btn-danger { background: rgba(255, 68, 68, 0.2); border: 1px solid rgba(255, 68, 68, 0.4); color: #ff4444; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; transition: all 0.3s ease; }
.btn-danger:hover { background: rgba(255, 68, 68, 0.3); transform: translateY(-1px); }
.empty-users { text-align: center; padding: 40px 20px; color: #888; }
.empty-users h4 { margin-bottom: 10px; color: #ccc; }

@media (max-width: 768px) {
    .vms-header { padding: 10px 15px; }
    .vms-header h1 { font-size: 1.5rem; letter-spacing: 2px; }
    .camera-selector { min-width: 150px; font-size: 0.8rem; }
    .register-btn, .manage-btn { padding: 6px 12px; font-size: 0.8rem; }
    .recognition-overlay { top: 10px; left: 10px; right: 10px; }
    .user-info { padding: 10px 15px; }
    .status-bar { padding: 8px 15px; font-size: 0.8rem; }
    .modal-content { width: 95%; margin: 20px; }
    .modal-header, .modal-body { padding: 15px 20px; }
}
.face-box { border: 2px solid #00ff88; background: rgba(0, 255, 136, 0.1); }
.face-box.unknown { border-color: #ff4444; background: rgba(255, 68, 68, 0.1); }
</style>

<script>
class VMSSystem {
  constructor() {
    this.video = null;
    this.canvas = null;
    this.ctx = null;
    this.stream = null;
    this.isRunning = false;
    this.modelsLoaded = false;
    this.faceMatcher = null;
    this.labeledDescriptors = [];
    this.cameras = [];
    this.currentCameraIndex = 0;
    this.detectionHistory = new Map();
    this.registrationMode = false;
    this.registrationData = { descriptors: [], startTime: null, duration: 7000 }; // 7s for better variety
    this.userManagementModal = null;

    this.init();
  }

  async init() {
    await this.loadModels();
    await this.loadCameras();
    await this.loadUsers();
    this.setupEventListeners();
    this.startVMS();
  }

  async loadModels() {
    const MODEL_URL = 'https://cdn.jsdelivr.net/npm/@vladmandic/face-api@latest/model/';
    try {
      this.updateStatus('Loading AI models...');
      await faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL);
      await faceapi.nets.ssdMobilenetv1.loadFromUri(MODEL_URL);
      await faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL);
      await faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL);
      this.modelsLoaded = true;
      this.updateStatus('AI models loaded successfully');
      console.log('VMS: Face recognition models loaded');
    } catch (error) {
      console.error('Error loading models:', error);
      this.updateStatus('Error loading AI models');
    }
  }

  async loadCameras() {
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      this.cameras = devices.filter(device => device.kind === 'videoinput');

      const cameraSelect = document.getElementById('cameraSelect');
      cameraSelect.innerHTML = '';

      if (this.cameras.length === 0) {
        cameraSelect.innerHTML = '<option>No cameras found</option>';
        return;
      }

      this.cameras.forEach((camera, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.textContent = camera.label || `Camera ${index + 1}`;
        cameraSelect.appendChild(option);
      });

      cameraSelect.value = this.currentCameraIndex;
    } catch (error) {
      console.error('Error loading cameras:', error);
      this.updateStatus('Error accessing cameras');
    }
  }

  async loadUsers() {
    try {
      const response = await fetch('/api/users');
      const users = await response.json();

      if (!Array.isArray(users) || users.length === 0) {
        this.updateStatus('No registered users - Ready to register new faces');
        this.faceMatcher = null;
        return;
      }

      this.labeledDescriptors = users.map(user => {
        const descriptors = user.descriptors.map(desc => new Float32Array(desc));
        return new faceapi.LabeledFaceDescriptors(user.name, descriptors);
      });

      this.faceMatcher = new faceapi.FaceMatcher(this.labeledDescriptors, 0.6);
      this.updateStatus(`${users.length} users loaded`);
    } catch (error) {
      console.error('Error loading users:', error);
      this.updateStatus('Error loading users');
    }
  }

  setupEventListeners() {
    document.getElementById('cameraSelect').addEventListener('change', (e) => {
      this.currentCameraIndex = parseInt(e.target.value);
      this.switchCamera();
    });

    document.getElementById('flipCamera').addEventListener('click', () => this.flipCamera());
    document.getElementById('registerUserBtn').addEventListener('click', () => this.showRegistrationModal());
    document.getElementById('manageUsersBtn').addEventListener('click', () => this.showUserManagementModal());

    // Registration modal
    document.getElementById('closeModal').addEventListener('click', () => this.closeRegistrationModal());
   document.getElementById('startRegistration')
  .addEventListener('click', this.startRegistration.bind(this));
    document.getElementById('cancelRegistration').addEventListener('click', () => this.closeRegistrationModal());

    // User management modal
    document.getElementById('closeUserModal').addEventListener('click', () => this.closeUserManagementModal());

    // Close on backdrop click
    document.getElementById('registrationModal').addEventListener('click', (e) => {
      if (e.target.id === 'registrationModal') this.closeRegistrationModal();
    });
    document.getElementById('userManagementModal').addEventListener('click', (e) => {
      if (e.target.id === 'userManagementModal') this.closeUserManagementModal();
    });
  }

  async startVMS() {
    if (!this.modelsLoaded) {
      this.updateStatus('Waiting for AI models...');
      setTimeout(() => this.startVMS(), 500);
      return;
    }
    try {
      await this.startCamera();
      this.isRunning = true;
      this.detectFaces();
      this.updateStatus('VMS Active - Monitoring');
    } catch (error) {
      console.error('Error starting VMS:', error);
      let errorMessage = 'Error starting camera';
      if (error.name === 'NotAllowedError') errorMessage = 'Camera access denied. Please allow camera permissions and refresh the page.';
      else if (error.name === 'NotFoundError') errorMessage = 'No camera found. Please connect a camera and refresh the page.';
      else if (error.name === 'NotReadableError') errorMessage = 'Camera is already in use by another application. Please close other apps using the camera.';
      else if (error.name === 'OverconstrainedError') errorMessage = 'Camera does not support the required settings. Trying with default settings...';
      else if (error.name === 'SecurityError') errorMessage = 'Camera access blocked due to security restrictions. Please use HTTPS or localhost.';
      this.updateStatus(errorMessage);
    }
  }

  async startCamera() {
    if (this.stream) {
      this.stream.getTracks().forEach(track => track.stop());
    }

    const constraints = {
      video: {
        deviceId: this.cameras[this.currentCameraIndex]?.deviceId,
        width: { ideal: 640 },
        height: { ideal: 480 },
        frameRate: { ideal: 15, max: 30 },
      }
    };

    this.stream = await navigator.mediaDevices.getUserMedia(constraints);
    this.video = document.getElementById('video');
    this.canvas = document.getElementById('overlay');
    this.ctx = this.canvas.getContext('2d');
    this.video.srcObject = this.stream;

    return new Promise(resolve => {
      this.video.onloadedmetadata = () => {
        this.canvas.width = this.video.videoWidth;
        this.canvas.height = this.video.videoHeight;
        resolve();
      };
    });
  }

  async switchCamera() {
    if (this.isRunning) await this.startCamera();
  }

  flipCamera() {
    if (this.cameras.length > 1) {
      this.currentCameraIndex = (this.currentCameraIndex + 1) % this.cameras.length;
      document.getElementById('cameraSelect').value = this.currentCameraIndex;
      this.switchCamera();
    }
  }

  async detectFaces() {
    if (!this.isRunning || !this.video || this.video.paused || this.video.ended) {
      setTimeout(() => this.detectFaces(), 100);
      return;
    }

    try {
      const detections = await faceapi
        .detectAllFaces(this.video, new faceapi.SsdMobilenetv1Options({ minConfidence: 0.5, maxResults: 10 }))
        .withFaceLandmarks()
        .withFaceDescriptors();

      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

      const faceCount = detections.length;
      document.getElementById('faceCount').textContent = `${faceCount} face${faceCount !== 1 ? 's' : ''} detected`;

      if (detections.length > 0) {
        const resizedDetections = faceapi.resizeResults(detections, {
          width: this.video.videoWidth,
          height: this.video.videoHeight
        });
        this.processDetections(resizedDetections);
      } else {
        this.hideUserInfo();
      }
    } catch (error) {
      console.error('Detection error:', error);
    }

    setTimeout(() => this.detectFaces(), 100);
  }

  processDetections(detections) {
    const recognizedUsers = [];
    const unknownFaces = [];

    for (let i = 0; i < detections.length; i++) {
      const detection = detections[i];
      const box = detection.detection.box;

      // Draw base box
      this.ctx.strokeStyle = '#00ff88';
      this.ctx.lineWidth = 2;
      this.ctx.strokeRect(box.x, box.y, box.width, box.height);

      if (this.faceMatcher && detection.descriptor) {
        const match = this.faceMatcher.findBestMatch(detection.descriptor);
        if (match.label !== 'unknown' && match.distance < 0.5) {
          const confidence = Math.round((1 - match.distance) * 100);
          recognizedUsers.push({ name: match.label, confidence, box });

          this.ctx.strokeStyle = '#00ff88';
          this.ctx.lineWidth = 2;
          this.ctx.strokeRect(box.x, box.y, box.width, box.height);
          this.ctx.fillStyle = '#00ff88';
          this.ctx.fillRect(box.x, box.y - 25, Math.max(box.width, 120), 25);
          this.ctx.fillStyle = '#000';
          this.ctx.font = 'bold 12px Arial';
          this.ctx.fillText(`${match.label} (${confidence}%)`, box.x + 5, box.y - 8);
        } else {
          unknownFaces.push({ box });
          this.ctx.strokeStyle = '#ff4444';
          this.ctx.lineWidth = 2;
          this.ctx.strokeRect(box.x, box.y, box.width, box.height);
          this.ctx.fillStyle = '#ff4444';
          this.ctx.fillRect(box.x, box.y - 25, Math.max(box.width, 80), 25);
          this.ctx.fillStyle = '#fff';
          this.ctx.font = 'bold 12px Arial';
          this.ctx.fillText('Unknown', box.x + 5, box.y - 8);
        }
      } else {
        unknownFaces.push({ box });
        this.ctx.strokeStyle = '#ff4444';
        this.ctx.lineWidth = 2;
        this.ctx.strokeRect(box.x, box.y, box.width, box.height);
        this.ctx.fillStyle = '#ff4444';
        this.ctx.fillRect(box.x, box.y - 25, Math.max(box.width, 80), 25);
        this.ctx.fillStyle = '#fff';
        this.ctx.font = 'bold 12px Arial';
        this.ctx.fillText('Unknown', box.x + 5, box.y - 8);
      }
    }

    this.updateUserInfo(recognizedUsers, unknownFaces);
  }

  updateUserInfo(recognizedUsers, unknownFaces) {
    const userInfo = document.getElementById('userInfo');
    userInfo.style.display = 'block';

    if (recognizedUsers.length > 0) {
      const user = recognizedUsers[0];
      userInfo.innerHTML = `<h3>‚úÖ ${user.name}</h3><p>Confidence: ${user.confidence}% | Access Granted</p>`;
      userInfo.className = 'user-info recognized';
    } else if (unknownFaces.length > 0) {
      userInfo.innerHTML = `<h3>‚ö†Ô∏è Unknown Person</h3><p>${unknownFaces.length} unrecognized face${unknownFaces.length > 1 ? 's' : ''} detected</p>`;
      userInfo.className = 'user-info unknown';
    } else {
      this.hideUserInfo();
    }
  }

  hideUserInfo() {
    const userInfo = document.getElementById('userInfo');
    userInfo.className = 'user-info';
    userInfo.style.display = 'none';
    userInfo.innerHTML = '';
  }

  showRegistrationModal() {
    if (this.registrationMode) return;
    document.getElementById('registrationModal').style.display = 'block';
    this.setupRegistrationCamera();
  }

  closeRegistrationModal() {
    document.getElementById('registrationModal').style.display = 'none';
    this.registrationMode = false;

    this.registrationData.descriptors = [];
    this.registrationData.startTime = null;

    document.getElementById('registrationProgress').style.display = 'none';
    document.getElementById('progressFill').style.width = '0%';
    this.registrationDetectionLoop = null;

    const regVideo = document.getElementById('registrationVideo');
    if (regVideo.srcObject && regVideo.srcObject !== this.stream) {
      // We reused main stream; don‚Äôt stop it. Only stop if it was a separate stream (it won‚Äôt be in this impl).
      regVideo.srcObject.getTracks().forEach(t => t.stop());
    }
    regVideo.srcObject = null;

    const regCanvas = document.getElementById('registrationOverlay');
    const regCtx = regCanvas.getContext('2d');
    regCtx.clearRect(0, 0, regCanvas.width, regCanvas.height);

    document.getElementById('newUserName').value = '';
    document.getElementById('startRegistration').style.display = 'inline-block';
    document.getElementById('cancelRegistration').textContent = 'Cancel';
  }

  async setupRegistrationCamera() {
  try {
    const regVideo = document.getElementById('registrationVideo');
    const regCanvas = document.getElementById('registrationOverlay');
    const regCtx = regCanvas.getContext('2d');

    // Reuse main stream
    if (!this.stream) await this.startCamera();
    regVideo.srcObject = this.stream;

    await new Promise(resolve => {
      regVideo.onloadedmetadata = () => {
        // NOTE: keep a slightly larger working canvas for better detection
        regCanvas.width = 320;
        regCanvas.height = 240;
        resolve();
      };
    });

    // Offscreen canvas to snapshot the current frame (improves stability)
    const snap = document.createElement('canvas');
    snap.width = 320;
    snap.height = 240;
    const snapCtx = snap.getContext('2d');

    // draw a simple ‚Äúface mask‚Äù guide
    const drawGuide = () => {
      regCtx.save();
      regCtx.globalAlpha = 0.25;
      regCtx.fillStyle = '#000';
      regCtx.fillRect(0, 0, regCanvas.width, regCanvas.height);
      regCtx.globalAlpha = 1;

      // cut out an ellipse in the middle
      regCtx.globalCompositeOperation = 'destination-out';
      regCtx.beginPath();
      regCtx.ellipse(regCanvas.width/2, regCanvas.height/2, 90, 120, 0, 0, Math.PI*2);
      regCtx.fill();
      regCtx.globalCompositeOperation = 'source-over';

      regCtx.strokeStyle = '#00ff88';
      regCtx.lineWidth = 2;
      regCtx.beginPath();
      regCtx.ellipse(regCanvas.width/2, regCanvas.height/2, 90, 120, 0, 0, Math.PI*2);
      regCtx.stroke();

      regCtx.fillStyle = '#ccc';
      regCtx.font = 'bold 12px system-ui, Arial';
      regCtx.textAlign = 'center';
      regCtx.fillText('Align your face inside the oval', regCanvas.width/2, 20);
      regCtx.restore();
    };

    const tfdOpts = new faceapi.TinyFaceDetectorOptions({
      inputSize: 416,        // larger = more accurate
      scoreThreshold: 0.4    // a bit relaxed for indoor lighting
    });

    this.registrationDetectionLoop = async () => {
      try {
        if (!this.modelsLoaded) {
          setTimeout(this.registrationDetectionLoop, 200);
          return;
        }
        if (document.getElementById('registrationModal').style.display !== 'block' || regVideo.paused || regVideo.ended) {
          return;
        }

        // 1) Snapshot current frame to offscreen canvas
        snapCtx.drawImage(regVideo, 0, 0, snap.width, snap.height);

        // 2) Run detection on the snapshot
        const det = await faceapi
          .detectSingleFace(snap, tfdOpts)
          .withFaceLandmarks()
          .withFaceDescriptor();

        // 3) Clear and redraw guide
        regCtx.clearRect(0, 0, regCanvas.width, regCanvas.height);
        drawGuide();

        if (det) {
          // scale box to overlay canvas
          const scaleX = regCanvas.width / snap.width;
          const scaleY = regCanvas.height / snap.height;
          const box = new faceapi.Box(
            det.detection.box.x * scaleX,
            det.detection.box.y * scaleY,
            det.detection.box.width * scaleX,
            det.detection.box.height * scaleY
          );

          // draw box + label
          regCtx.strokeStyle = '#00ff88';
          regCtx.lineWidth = 3;
          regCtx.strokeRect(box.x, box.y, box.width, box.height);
          regCtx.fillStyle = '#00ff88';
          regCtx.fillRect(box.x, Math.max(0, box.y - 22), Math.max(120, box.width), 20);
          regCtx.fillStyle = '#000';
          regCtx.font = 'bold 12px system-ui, Arial';
          regCtx.fillText('Face Detected ‚úì', box.x + 6, Math.max(12, box.y - 8));

          // 4) Collect descriptor while capturing window is active
          if (this.registrationMode && this.registrationData.startTime) {
            // keep as Float32Array for proper distance calculations later
            this.registrationData.descriptors.push(new Float32Array(det.descriptor));
          }
        } else {
          // hint text
          regCtx.fillStyle = '#ff6666';
          regCtx.font = 'bold 14px system-ui, Arial';
          regCtx.textAlign = 'center';
          regCtx.fillText('Center your face | Good light | Look at camera', regCanvas.width/2, regCanvas.height - 8);
          regCtx.textAlign = 'left';
        }
      } catch (err) {
        console.error('Registration detection error:', err);
      }

      if (this.registrationDetectionLoop) {
        setTimeout(this.registrationDetectionLoop, 100);
      }
    };

    drawGuide();
    this.registrationDetectionLoop();
  } catch (error) {
    console.error('Registration camera error:', error);
    alert('Failed to access camera for registration. Please ensure camera permissions are granted and use HTTPS/localhost.');
  }
}


  async completeRegistration(userName) {
    try {
      const samples = this.registrationData.descriptors.length;
      if (samples < 5) {
        alert(`Only ${samples} face samples captured. Try again with better lighting and keep your face centered.`);
        this.closeRegistrationModal();
        return;
      }

      // Filter near-duplicates to keep variety
      const src = this.registrationData.descriptors;
      const uniqueDescriptors = src.filter((d, i) =>
        i === 0 || !src.slice(0, i).some(p => faceapi.euclideanDistance(d, p) < 0.1)
      );

      if (uniqueDescriptors.length < 3) {
        alert(`Only ${uniqueDescriptors.length} unique sample(s). Move slightly and try again.`);
        this.closeRegistrationModal();
        return;
      }

      // Convert to plain arrays for transport
      const payload = uniqueDescriptors.map(d => Array.from(d));

      const response = await fetch('/api/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name: userName, descriptors: payload })
      });

      const result = await response.json();

      if (response.ok) {
        alert(`Registration successful! ${userName} registered with ${uniqueDescriptors.length} face samples.`);
        await this.loadUsers();
        this.closeRegistrationModal();
      } else {
        alert(result.error || 'Registration failed');
        document.getElementById('startRegistration').style.display = 'inline-block';
        document.getElementById('cancelRegistration').textContent = 'Cancel';
      }
    } catch (error) {
      console.error('Registration error:', error);
      alert('Registration failed. Please try again.');
      document.getElementById('startRegistration').style.display = 'inline-block';
      document.getElementById('cancelRegistration').textContent = 'Cancel';
      this.closeRegistrationModal();
    }
  }

  async showUserManagementModal() {
    document.getElementById('userManagementModal').style.display = 'block';
    await this.loadUsersList();
  }

  closeUserManagementModal() {
    document.getElementById('userManagementModal').style.display = 'none';
  }

  async loadUsersList() {
    const usersList = document.getElementById('usersList');
    usersList.innerHTML = '<p>Loading users...</p>';

    try {
      const response = await fetch('/api/users');
      const users = await response.json();

      if (!Array.isArray(users) || users.length === 0) {
        usersList.innerHTML = `
          <div class="empty-users">
            <h4>No Users Registered</h4>
            <p>Register your first user to get started</p>
          </div>`;
        return;
      }

      usersList.innerHTML = users.map(user => `
        <div class="user-item">
          <div class="user-details">
            <h4>${user.name}</h4>
            <p>Registered: ${new Date(user.createdAt).toLocaleDateString()}</p>
            <p>Face samples: ${user.descriptors.length}</p>
          </div>
          <div class="user-actions">
            <button class="btn-danger" onclick="vmsSystem.deleteUser('${user.id}', '${user.name}')">üóëÔ∏è Delete</button>
          </div>
        </div>
      `).join('');
    } catch (error) {
      console.error('Error loading users list:', error);
      usersList.innerHTML = '<p>Error loading users</p>';
    }
  }

  async deleteUser(userId, userName) {
    if (!confirm(`Delete user "${userName}"? This cannot be undone.`)) return;
    try {
      const response = await fetch(`/api/users/${userId}`, { method: 'DELETE' });
      if (response.ok) {
        alert(`User "${userName}" deleted successfully`);
        await this.loadUsersList();
        await this.loadUsers();
      } else {
        alert('Failed to delete user');
      }
    } catch (error) {
      console.error('Delete error:', error);
      alert('Error deleting user');
    }
  }

  updateStatus(message) {
    document.getElementById('statusText').textContent = message;
    console.log('VMS:', message);
  }
}

document.addEventListener('DOMContentLoaded', () => {
  window.vmsSystem = new VMSSystem();
});
</script>

</body>
</html>
